#!/usr/bin/env bash
# lazypodman: A convenience wrapper to use Lazydocker with local/remote Podman.
#
# Features
#   - Local mode: ensure rootless Podman API socket and run Lazydocker.
#   - Remote mode: pick from `podman-remote system connection list`,
#     open an SSH UDS (Unix Domain Socket) tunnel to the remote rootless Podman
#     socket, and run Lazydocker.
#   - Persist tunnels with --persist (keep tunnel after Lazydocker exits).
#   - List/stop/kill/restart tunnels created by this tool.
#   - Open-only mode (create the tunnel, print env exports, do NOT launch TUI).
#
# Soft deps:
#   - jq   (remote selection & JSON parsing)
#   - fzf  (optional fuzzy picker; falls back to basic menu)
#   - OpenSSH with UDS forwarding support (common on Linux/macOS)
#
# Notes
#   - Tunnels and control sockets live under $WORKDIR (~/.lazypodman).
#   - We set DOCKER_API_VERSION=1.41 by default for Podman compatibility.

set -euo pipefail

# --------------------------- Configuration -----------------------------------

API_FLOOR="${DOCKER_API_VERSION:-1.41}"            # conservative Docker API for Podman
RUNTIME_DIR="${XDG_RUNTIME_DIR:-/run/user/$(id -u)}"
LOCAL_PODMAN_SOCK="${RUNTIME_DIR}/podman/podman.sock"
WORKDIR="${HOME}/.lazypodman"                      # control + local socks + meta
mkdir -p "${WORKDIR}"

# ----------------------------- Utilities -------------------------------------

die(){ echo "Error: $*" >&2; exit 1; }
have(){ command -v "$1" >/dev/null 2>&1; }

usage(){
  cat <<'EOF'
Usage:
  lazypodman                        # interactive menu
  lazypodman --local                # local rootless Podman
  lazypodman --remote <name>        # remote by connection name (run Lazydocker)
  lazypodman --remote <name> --persist
                                    # keep tunnel running after exit
  lazypodman --open <name>          # ONLY open tunnel (no Lazydocker), print exports
  lazypodman --restart <name>       # stop & reopen ONLY the named tunnel, print exports
  lazypodman --list-tunnels         # list tunnels (state, age, SSH PID, remote uptime)
  lazypodman --stop <name>          # stop ONLY the named tunnel
  lazypodman --kill-tunnels         # close ALL tunnels created by this tool
  lazypodman --stop-all             # alias for --kill-tunnels
Options:
  --persist         Keep SSH tunnel alive after Lazydocker exits (remote mode)
Env:
  DOCKER_API_VERSION (default: 1.41)
EOF
}

# Ensure the local rootless Podman socket is up and listening
ensure_local_socket(){
  if have loginctl; then loginctl enable-linger "$USER" >/dev/null 2>&1 || true; fi
  systemctl --user enable --now podman.socket >/dev/null 2>&1 || true
  [[ -S "$LOCAL_PODMAN_SOCK" ]] || die "Local socket not found at $LOCAL_PODMAN_SOCK"
}

# Obtain JSON of podman-remote connections (requires Podman 4+)
conn_json(){
  if podman-remote system connection list --format json >/dev/null 2>&1; then
    podman-remote system connection list --format json
  else
    die "podman-remote v4+ with JSON output is required."
  fi
}

# List connections with the default first, then alphabetical
list_conns_sorted(){
  conn_json | jq -r '
    sort_by(.Name) | sort_by((.Default|not)) |
    map("\(.Name)\t\(.URI)\t\(.Default)\t\(.Identity // "")")[]'
}

# Choose a remote connection interactively (fzf if available)
pick_remote(){
  have jq || die "Please install jq."
  local lines; lines="$(list_conns_sorted)"
  [[ -n "$lines" ]] || die "No podman-remote connections found."

  if have fzf; then
    echo "$lines" \
    | awk -F'\t' '{printf "%s\t%s%s\n",$1,$2,($3=="true"?" [default]":"")}' \
    | fzf --prompt="Remote > " --with-nth=1 \
          --preview='echo {2}' --preview-window=down,3,wrap \
    | awk '{print $1}'
  else
    echo "Available podman-remote connections:"
    nl -w2 -s") " <(echo "$lines" | awk -F'\t' '{printf "%s%s -> %s\n",$1,($3=="true"?" [default]":""),$2}')
    local n total; total="$(echo "$lines" | wc -l | tr -d ' ')"
    read -rp "Pick a connection [1-${total}]: " n
    [[ -z "${n:-}" ]] && n=1
    echo "$lines" | sed -n "${n}p" | awk -F'\t' '{print $1}'
  fi
}

# Extract a single connection object by name (as JSON string)
get_conn(){
  local name="$1"
  conn_json | jq -r --arg n "$name" '
    map(select(.Name==$n)) | (.[0] // empty) | @json'
}

# Parse ssh:// URIs formatted like:
#   ssh://[user@]host[:port]/run/user/1000/podman/podman.sock
# Returns a tab-separated record: user  host  port  path
parse_ssh_uri(){
  local uri="$1"
  [[ "$uri" == ssh://* ]] || die "Unsupported URI (expect ssh://): $uri"
  local rest="${uri#ssh://}"
  local hostpart="${rest%%/*}"
  local pathpart="/${rest#*/}"
  [[ -n "$hostpart" && -n "$pathpart" ]] || die "Malformed URI: $uri"

  local user host port
  if [[ "$hostpart" == *"@"* ]]; then
    user="${hostpart%@*}"; host="${hostpart#*@}"
  else
    user=""; host="$hostpart"
  fi
  if [[ "$host" == *":"* ]]; then port="${host##*:}"; host="${host%%:*}"; else port=""; fi

  printf '%s\t%s\t%s\t%s\n' "$user" "$host" "$port" "$pathpart"
}

# Helper: path for the SSH control socket (per connection name)
ctrl_sock_for(){ printf '%s/ctrl.%s.sock' "$WORKDIR" "$1"; }

# Helper: path for the local UDS that forwards to the remote Podman socket
local_sock_for(){ printf '%s/%s.sock'      "$WORKDIR" "$1"; }

# Open an SSH UDS tunnel for a connection name/URI (optionally with Identity)
# Returns the local socket path on stdout. Also writes $csock.meta with 'dest=' and 'rpath='.
open_tunnel(){
  local name="$1" uri="$2" identity="$3"
  local parsed user host port rpath
  parsed="$(parse_ssh_uri "$uri")"
  user="$(echo "$parsed" | awk -F'\t' '{print $1}')"
  host="$(echo "$parsed" | awk -F'\t' '{print $2}')"
  port="$(echo "$parsed" | awk -F'\t' '{print $3}')"
  rpath="$(echo "$parsed" | awk -F'\t' '{print $4}')"

  local csock; csock="$(ctrl_sock_for "$name")"
  local lsock; lsock="$(local_sock_for "$name")"
  rm -f "$lsock" 2>/dev/null || true

  local dest="$host"; [[ -n "$user" ]] && dest="${user}@${dest}"
  local args=(-MNf -S "$csock" -L "${lsock}:${rpath}")
  [[ -n "$port" ]] && args+=(-p "$port")
  [[ -n "$identity" && "$identity" != "null" ]] && args+=(-i "$identity")

  # Start background control master + UDS forward
  ssh "${args[@]}" "$dest"

  # Persist small metadata for list/restart: remote destination and remote socket path
  printf 'dest=%s\nrpath=%s\n' "$dest" "$rpath" > "${csock}.meta" 2>/dev/null || true

  echo "$lsock"
}

# Close one tunnel (best-effort)
close_tunnel(){
  local name="$1"
  local csock; csock="$(ctrl_sock_for "$name")"
  local lsock; lsock="$(local_sock_for "$name")"
  ssh -S "$csock" -O exit dummy >/dev/null 2>&1 || true
  rm -f "$csock" "$lsock" "${csock}.meta" 2>/dev/null || true
}

# Close all tunnels created by this tool
kill_all_tunnels(){
  find "$WORKDIR" -maxdepth 1 -type s -name 'ctrl.*.sock' -print0 2>/dev/null \
    | xargs -0 -I{} bash -c 'ssh -S "{}" -O exit dummy >/dev/null 2>&1 || true'
  rm -f "$WORKDIR"/ctrl.*.sock "$WORKDIR"/*.sock "$WORKDIR"/ctrl.*.sock.meta 2>/dev/null || true
  echo "All lazypodman tunnels closed."
}

# Human-friendly age from file mtime (e.g., "5m", "2h", "1d")
file_age(){
  local f="$1" secs
  if [[ "$(uname)" == "Darwin" ]]; then
    secs=$(( $(date +%s) - $(stat -f %m "$f") ))
  else
    secs=$(( $(date +%s) - $(stat -c %Y "$f") ))
  fi
  if   (( secs < 120 )); then echo "${secs}s"
  elif (( secs < 7200 )); then echo "$((secs/60))m"
  elif (( secs < 172800 )); then echo "$((secs/3600))h"
  else echo "$((secs/86400))d"
  fi
}

# Check if a control master is up for a given ctrl socket
is_master_running(){
  local csock="$1"
  ssh -S "$csock" -O check dummy >/dev/null 2>&1
}

# Get SSH master PID, if running (parse "Master running (pid XXXX)")
get_master_pid(){
  local csock="$1" out
  out="$(ssh -S "$csock" -O check dummy 2>&1 || true)"
  # Typical output: "Master running (pid 12345)"
  echo "$out" | sed -nE 's/.*pid[[:space:]]+([0-9]+).*/\1/p' | head -n1
}

# Run a remote command via the existing control socket & destination
ssh_via_csock(){
  local csock="$1" dest="$2" cmd="$3"
  # Use a short timeout if available to avoid hanging the list view
  if have timeout; then
    timeout 3s ssh -S "$csock" "$dest" bash -lc "$cmd" 2>/dev/null || true
  else
    ssh -o ConnectTimeout=3 -S "$csock" "$dest" bash -lc "$cmd" 2>/dev/null || true
  fi
}

# List tunnels created by this tool, showing state, age, SSH PID, and remote uptime
list_tunnels(){
  shopt -s nullglob
  local any=0
  for csock in "$WORKDIR"/ctrl.*.sock; do
    any=1
    local name; name="$(basename "$csock")"
    name="${name#ctrl.}"; name="${name%.sock}"
    local lsock; lsock="$(local_sock_for "$name")"
    local meta="$csock.meta"
    local dest="unknown" rpath="unknown"
    [[ -f "$meta" ]] && { source "$meta"; dest="${dest:-unknown}"; rpath="${rpath:-unknown}"; }

    local state="down"
    is_master_running "$csock" && state="up"

    local age="?"
    [[ -e "$csock" ]] && age="$(file_age "$csock")"

    local pid=""
    [[ "$state" == "up" ]] && pid="$(get_master_pid "$csock")"

    # Remote uptime is best-effort; try 'uptime -p' then fallback to 'uptime'
    local rup="n/a"
    if [[ "$state" == "up" && "$dest" != "unknown" ]]; then
      rup="$(ssh_via_csock "$csock" "$dest" 'uptime -p || uptime' | tr -d '\r' | head -n1)"
      [[ -z "$rup" ]] && rup="n/a"
    fi

    printf "%-20s %-4s  age:%-6s  pid:%-6s  local:%s\n           remote:%s  uptime:%s\n" \
      "$name" "$state" "$age" "${pid:-?}" "$lsock" "$rpath" "$rup"
  done
  if [[ $any -eq 0 ]]; then
    echo "No tunnels found in $WORKDIR"
  fi
}

# Print helpful exports for a given local socket
print_exports(){
  local lsock="$1"
  cat <<EOF
# Export these in your shell to point Docker-compatible clients at the tunnel:
export DOCKER_HOST=unix://$lsock
export DOCKER_API_VERSION=${API_FLOOR}
# Example:
#   docker ps
#   lazydocker
EOF
}

# Run Lazydocker against local Podman
run_local(){
  ensure_local_socket
  export DOCKER_HOST="unix://$LOCAL_PODMAN_SOCK"
  export DOCKER_API_VERSION="$API_FLOOR"
  exec lazydocker
}

# Run Lazydocker against a remote (optionally persist the tunnel)
run_remote(){
  have jq || die "Please install jq."
  local name="$1" persist="${2:-0}"

  local conn; conn="$(get_conn "$name")"
  [[ -n "$conn" && "$conn" != "null" ]] || die "Remote connection '$name' not found."

  local uri; uri="$(echo "$conn" | jq -r '.URI')"
  local identity; identity="$(echo "$conn" | jq -r '.Identity // empty')"

  local lsock; lsock="$(open_tunnel "$name" "$uri" "$identity")"

  export DOCKER_HOST="unix://$lsock"
  export DOCKER_API_VERSION="$API_FLOOR"

  if [[ "$persist" == "1" ]]; then
    echo "Tunnel persisted for '$name' at $lsock"
    echo "Close later with: lazypodman --stop '$name'    (single)"
    echo "            or:   lazypodman --kill-tunnels     (all)"
    exec lazydocker
  else
    trap "close_tunnel '$name'" EXIT
    exec lazydocker
  fi
}

# Open-only: create the tunnel, print exports, and return
open_only(){
  have jq || die "Please install jq."
  local name="$1"
  local conn; conn="$(get_conn "$name")"
  [[ -n "$conn" && "$conn" != "null" ]] || die "Remote connection '$name' not found."
  local uri; uri="$(echo "$conn" | jq -r '.URI')"
  local identity; identity="$(echo "$conn" | jq -r '.Identity // empty')"
  local lsock; lsock="$(open_tunnel "$name" "$uri" "$identity")"
  echo "Tunnel opened for '$name' -> $lsock"
  print_exports "$lsock"
}

# Stop only one tunnel by name
stop_one(){
  local name="$1"
  local csock; csock="$(ctrl_sock_for "$name")"
  local lsock; lsock="$(local_sock_for "$name")"
  if [[ ! -S "$csock" && ! -S "$lsock" && ! -f "${csock}.meta" ]]; then
    die "No tunnel artifacts found for '$name' in $WORKDIR"
  fi
  close_tunnel "$name"
  echo "Stopped tunnel '$name'."
}

# Restart only one tunnel by name: stop, reopen, print exports (no TUI)
restart_one(){
  have jq || die "Please install jq."
  local name="$1"

  # Stop (best-effort) if exists
  close_tunnel "$name" || true

  # Recreate from connection info
  local conn; conn="$(get_conn "$name")"
  [[ -n "$conn" && "$conn" != "null" ]] || die "Remote connection '$name' not found."
  local uri; uri="$(echo "$conn" | jq -r '.URI')"
  local identity; identity="$(echo "$conn" | jq -r '.Identity // empty')"
  local lsock; lsock="$(open_tunnel "$name" "$uri" "$identity")"

  echo "Restarted tunnel for '$name' -> $lsock"
  print_exports "$lsock"
}

# --------------------------- Arg parsing -------------------------------------

MODE=""              # "", "local", "remote", "open", "list", "kill", "stop", "restart"
REMOTE_NAME=""
PERSIST=0

if [[ $# -gt 0 ]]; then
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --help|-h) usage; exit 0 ;;
      --local) MODE="local"; shift ;;
      --remote) MODE="remote"; REMOTE_NAME="${2:-}"; [[ -n "$REMOTE_NAME" ]] || die "Missing remote name"; shift 2 ;;
      --open) MODE="open"; REMOTE_NAME="${2:-}"; [[ -n "$REMOTE_NAME" ]] || die "Missing remote name"; shift 2 ;;
      --restart) MODE="restart"; REMOTE_NAME="${2:-}"; [[ -n "$REMOTE_NAME" ]] || die "Missing remote name"; shift 2 ;;
      --persist) PERSIST=1; shift ;;
      --list-tunnels) MODE="list"; shift ;;
      --kill-tunnels|--stop-all) MODE="kill"; shift ;;
      --stop) MODE="stop"; REMOTE_NAME="${2:-}"; [[ -n "$REMOTE_NAME" ]] || die "Missing remote name"; shift 2 ;;
      *) echo "Unknown arg: $1"; usage; exit 1 ;;
    esac
  done
fi

# ------------------------------- Main ----------------------------------------

case "$MODE" in
  "local")
    run_local
    ;;
  "remote")
    run_remote "$REMOTE_NAME" "$PERSIST"
    ;;
  "open")
    open_only "$REMOTE_NAME"
    ;;
  "restart")
    restart_one "$REMOTE_NAME"
    ;;
  "list")
    list_tunnels
    ;;
  "stop")
    stop_one "$REMOTE_NAME"
    ;;
  "kill")
    kill_all_tunnels
    ;;
  "")
    # Interactive menu with a third option: open-only
    echo "How do you want to connect?"
    echo "  1) Local (rootless) Podman on this host"
    echo "  2) Remote Podman via podman-remote connection (run Lazydocker)"
    echo "  3) Remote Podman: OPEN TUNNEL ONLY (no Lazydocker)"
    read -rp "Choose [1/2/3]: " choice
    choice="${choice:-1}"
    case "$choice" in
      1) run_local ;;
      2)
        name="$(pick_remote)"; [[ -n "$name" ]] || die "No selection made."
        read -rp "Keep tunnel alive after exit? [y/N]: " yn
        [[ "${yn:-N}" =~ ^[Yy]$ ]] && PERSIST=1 || PERSIST=0
        run_remote "$name" "$PERSIST"
        ;;
      3)
        name="$(pick_remote)"; [[ -n "$name" ]] || die "No selection made."
        open_only "$name"
        ;;
      *) die "Invalid choice." ;;
    esac
    ;;
  *)
    die "Unknown mode. See --help."
    ;;
esac

